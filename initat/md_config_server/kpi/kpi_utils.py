# Copyright (C) 2015, 2016-2017 Bernhard Mallinger, Andreas Lang-Nevyjel, init.at
#
# this file is part of icsw-server-server
#
# Send feedback to: <mallinger@init.at>, <lang-nevyjel@init.at>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License Version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

import ast


def print_tree(t, i=0):
    print("    " * i, t, t.origin.type)
    for p in t.origin.operands:
        print_tree(p, i + 1)


def astdump(node, annotate_fields=True, include_attributes=False, indent='  '):
    """
    Return a formatted dump of the tree in *node*.  This is mainly useful for
    debugging purposes.  The returned string will show the names and the values
    for fields.  This makes the code impossible to evaluate, so if evaluation is
    wanted *annotate_fields* must be set to False.  Attributes such as line
    numbers and column offsets are not dumped by default.  If this is wanted,
    *include_attributes* can be set to True.
    """
    def _format(node, level=0):
        if isinstance(node, ast.AST):
            fields = [
                (a, _format(b, level)) for a, b in ast.iter_fields(node)
            ]
            if include_attributes and node._attributes:
                fields.extend(
                    [
                        (a, _format(getattr(node, a), level)) for a in node._attributes
                    ]
                )
            return ''.join(
                [
                    node.__class__.__name__,
                    '(',
                    ', '.join(
                        (
                            '{}={}'.format(field, field) for field in fields
                        ) if annotate_fields else (b for a, b in fields)
                    ),
                    ')'
                ]
            )
        elif isinstance(node, list):
            lines = [
                "["
            ]
            lines.extend(
                (
                    indent * (level + 2) + _format(x, level + 2) + ',' for x in node
                )
            )
            if len(lines) > 1:
                lines.append(indent * (level + 1) + ']')
            else:
                lines[-1] += ']'
            return '\n'.join(lines)
        return repr(node)
    if not isinstance(node, ast.AST):
        raise TypeError('expected AST, got %r' % node.__class__.__name__)
    return _format(node)
