# Copyright (C) 2011-2017 Andreas Lang-Nevyjel, init.at
#
# Send feedback to: <lang-nevyjel@init.at>
#
# This file is part of icsw-server-server
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License Version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# -*- coding: utf-8 -*-
#


import math
import logging
import re
from lxml import etree

from django.apps import apps
from django.core.exceptions import ValidationError
from django.db import models
from django.db.models import Q, signals
from django.dispatch import receiver
from enum import Enum

from initat.cluster.backbone.models import device
from initat.cluster.backbone.exceptions import NoMatchingNetworkFoundError, \
    NoMatchingNetworkDeviceTypeFoundError
from initat.cluster.backbone.models.functions import check_empty_string, \
    check_integer
from initat.cluster.backbone.signals import BootsettingsChanged
from initat.constants import GEN_CS_NAME
from initat.tools import ipvx_tools, logging_tools, process_tools, config_store
from initat.tools.bgnotify.create import propagate_channel_object

__all__ = [
    "network",
    "network_type",
    "net_ip",
    "network_device_type",
    "netdevice",
    "netdevice_speed",
    "peer_information",
    "snmp_network_type",
    "NetDeviceDesiredStateEnum",
    "NetDeviceSNMPMonOptions",
    "NmapScan",
    "NmapScanIgnoredDevice"
]

logger = logging.getLogger(__name__)


class network_device_type(models.Model):
    idx = models.AutoField(db_column="network_device_type_idx", primary_key=True)
    identifier = models.CharField(unique=True, max_length=48, blank=False)
    name_re = models.CharField(max_length=128, default="^.*$")
    description = models.CharField(max_length=192)
    mac_bytes = models.PositiveIntegerField(default=6)
    allow_virtual_interfaces = models.BooleanField(default=True)
    # used for matching ?
    for_matching = models.BooleanField(default=True)
    auto_created = models.BooleanField(default=False)
    date = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = 'network_device_type'

    def match(self, devname):
        if self.allow_virtual_interfaces and devname.count(":") == 1:
            _m_name = devname.split(":")[0]
        else:
            _m_name = devname
        return re.match(self.name_re, _m_name)

    def info_string(self):
        return str(self)

    @staticmethod
    def create_new_type(ndev):
        new_re = "^{}$".format("\d+".join(re.split("\d+", ndev.devname)))
        if ndev.macaddr:
            mac_bytes = ndev.macaddr.replace("-", ":").count(":") + 1
        else:
            mac_bytes = 6
        # mac_bytes must have at least 6 bytes
        mac_bytes = min(6, mac_bytes)
        GN = "autogen-"
        gen_names = [
            _val for _val in network_device_type.objects.all().values_list("identifier", flat=True) if _val.startswith(GN)
        ]
        gen_idx = 0
        while True:
            gen_idx += 1
            new_name = "{}{:d}".format(GN, gen_idx)
            if new_name not in gen_names:
                break
        new_ndt = network_device_type(
            identifier=new_name,
            name_re=new_re,
            description="autogenerated from '{}'".format(ndev.devname),
            mac_bytes=mac_bytes,
            allow_virtual_interfaces=False,
            for_matching=True,
            auto_created=True,
        )
        new_ndt.save()
        return new_ndt

    def __str__(self):
        return "{} ({} [{:d}])".format(
            self.identifier,
            self.description,
            self.mac_bytes
        )


@receiver(signals.post_init, sender=network_device_type)
def network_device_type_post_init(sender, **kwargs):
    if "instance" in kwargs:
        cur_inst = kwargs["instance"]
        # print "*" * 20, cur_inst.identifier, cur_inst.pk, "+" * 20
        if cur_inst.name_re == "^.*$" and cur_inst.pk and not cur_inst.for_matching:
            if cur_inst.identifier in ["lo"]:
                cur_inst.name_re = "^{}$".format(cur_inst.identifier)
            else:
                cur_inst.name_re = "^{}\d+$".format(cur_inst.identifier)
            cur_inst.save()


@receiver(signals.pre_save, sender=network_device_type)
def network_device_type_pre_save(sender, **kwargs):
    if "instance" in kwargs:
        cur_inst = kwargs["instance"]
        if not(cur_inst.identifier.strip()):
            raise ValidationError("identifer must not be empty")
        if not re.match("^[a-zA-Z0-9\-]+$", cur_inst.identifier):
            raise ValidationError("identifier '{}' contains illegal characters".format(cur_inst.identifier))
        if not cur_inst.name_re.startswith("^"):
            cur_inst.name_re = "^{}".format(cur_inst.name_re)
        if not cur_inst.name_re.endswith("$"):
            cur_inst.name_re = "{}$".format(cur_inst.name_re)
        try:
            _cur_re = re.compile(cur_inst.name_re)
        except:
            raise ValidationError(
                "invalid re '{}': {}".format(
                    cur_inst.name_re,
                    process_tools.get_except_info()
                )
            )
        check_integer(cur_inst, "mac_bytes", min_val=6, max_val=24)


class network_type(models.Model):
    idx = models.AutoField(db_column="network_type_idx", primary_key=True)
    identifier = models.CharField(
        unique=True, max_length=3,
        choices=(
            ("b", "boot"),
            ("p", "prod"),
            ("s", "slave"),
            ("o", "other"),
            ("l", "local")
        )
    )
    description = models.CharField(max_length=192, blank=False)
    date = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = 'network_type'

    def __str__(self):
        return "{} ({})".format(
            self.description,
            self.identifier
        )


class _NetworkManager(models.Manager):
    def get_or_create_network(self, network_addr, netmask, gateway=None, context=None):
        """
        :type network_addr: ipvx_tools.icswIPv4
        :type netmask: ipvx_tools.icswIPv4
        :type gateway: ipvx_tools.IPv4 | None
        :param str context: string added to network name and info
        :rtype: network
        """
        try:
            cur_nw = self.get(Q(network=str(network_addr)) & Q(netmask=str(netmask)))
        except self.model.DoesNotExist:
            if str(network_addr).startswith("127."):
                _identifier = "l"
            else:
                _identifier = "o"
            info_str = " from {}".format(context) if context else ""
            gateway = str(gateway) if gateway else str(network_addr + ipvx_tools.IPv4("0.0.0.1"))
            cur_nw = self.model(
                network_type=network_type.objects.get(Q(identifier=_identifier)),
                short_names=False,
                identifier=network.get_unique_identifier(),
                name="autogenerated{}".format(info_str),
                info="autogenerated{}".format(info_str),
                network=str(network_addr),
                netmask=str(netmask),
                gateway=gateway,
                broadcast=str(~netmask | (network_addr & netmask)),
            )
            cur_nw.save()
        return cur_nw


class network(models.Model):
    objects = _NetworkManager()
    idx = models.AutoField(db_column="network_idx", primary_key=True)
    identifier = models.CharField(unique=True, max_length=255, blank=False)
    network_type = models.ForeignKey("network_type")
    master_network = models.ForeignKey("backbone.network", null=True, related_name="rel_master_network", blank=True)
    # should no longer be used, now in domain_tree_node
    short_names = models.BooleanField(default=True)
    # should no longer be used, now in domain_tree_node
    name = models.CharField(max_length=192, blank=True, default="")
    penalty = models.PositiveIntegerField(default=1, verbose_name="cost")
    # should no longer be used, now in domain_tree_node
    postfix = models.CharField(max_length=12, blank=True, default="")
    info = models.CharField(max_length=255, blank=True)
    network = models.GenericIPAddressField(blank=False)
    netmask = models.GenericIPAddressField(blank=False)
    broadcast = models.GenericIPAddressField(blank=False)
    gateway = models.GenericIPAddressField(blank=False)
    gw_pri = models.IntegerField(null=True, blank=True, default=1)
    # should no longer be used, now in domain_tree_node
    write_bind_config = models.BooleanField(default=False)
    # should no longer be used, now in domain_tree_node
    write_other_network_config = models.BooleanField(default=False)
    start_range = models.GenericIPAddressField(default="0.0.0.0")
    end_range = models.GenericIPAddressField(default="0.0.0.0")
    date = models.DateTimeField(auto_now_add=True)
    # preferred domain_tree_node
    preferred_domain_tree_node = models.ForeignKey("backbone.domain_tree_node", null=True, blank=True)
    network_device_type = models.ManyToManyField("backbone.network_device_type", blank=True)
    enforce_unique_ips = models.BooleanField(default=False)

    class ICSW_Meta:
        permissions = (
            ("modify_network", "modify global network settings", False),
            ("show_clusters", "show network clustering", False),
        )

    def get_free_ip(self):
        # see link() in backend/network.coffee
        _ignore_range = {None, "", "0.0.0.0"}
        free_ip = None
        if self.start_range not in _ignore_range and self.end_range not in _ignore_range:
            used_ips = {ipvx_tools.IPv4(_ip.ip) for _ip in self.net_ip_set.all()}
            offset = ipvx_tools.IPv4("0.0.0.1")
            free_ip = ipvx_tools.IPv4(self.start_range)
            while free_ip in used_ips:
                free_ip += offset
            if free_ip > ipvx_tools.IPv4(self.end_range):
                free_ip = None
        return free_ip

    @staticmethod
    def get_unique_identifier():
        _all_ids = network.objects.all().values_list("identifier", flat=True)
        gen_idx = 0
        while True:
            gen_idx += 1
            _name = "autogen{:d}".format(gen_idx)
            if _name not in _all_ids:
                break
        return _name

    def get_identifier(self):
        return self.network_type.identifier

    def get_type_name(self):
        return self.network_type.description

    def num_ip(self):
        return self.net_ip_set.all().count()

    class Meta:
        db_table = 'network'

    def get_info(self):
        all_slaves = self.rel_master_network.all()
        # return extended info
        log_str = "{} network '{}' has {}{}".format(
            self.network_type.get_identifier_display(),
            self.identifier,
            logging_tools.get_plural("slave network", len(all_slaves)),
            ": {}".format(
                [
                    cur_slave.identifier for cur_slave in all_slaves
                ]
            ) if all_slaves else "",
        )
        return log_str

    def info_string(self):
        return str(self)

    def __str__(self):
        return "{} ({}/{}, {})".format(
            self.identifier,
            self.network,
            ipvx_tools.get_network_name_from_mask(self.netmask),
            self.network_type.identifier
        )


@receiver(signals.post_init, sender=network)
def network_post_init(sender, **kwargs):
    if "instance" in kwargs:
        cur_inst = kwargs["instance"]
        cur_inst._pre_enforce_unique_ips = cur_inst.enforce_unique_ips


@receiver(signals.pre_save, sender=network)
def network_pre_save(sender, **kwargs):
    if "instance" in kwargs:
        cur_inst = kwargs["instance"]
        # what was the changed attribute
        change_attr = getattr(cur_inst, "change_attribute", None)
        check_integer(cur_inst, "penalty", min_val=-100, max_val=100)
        nw_type = cur_inst.network_type.identifier
        if cur_inst.rel_master_network.all().count() and nw_type != "p":
            raise ValidationError("slave networks exists, cannot change type")
        if nw_type != "s" and cur_inst.master_network_id:
            raise ValidationError("only slave networks can have a master")
        if nw_type == "s":
            if not cur_inst.master_network_id:
                raise ValidationError("slave network needs a master network")
            else:
                # print cur_inst.pk, cur_inst.master_network_id
                if cur_inst.master_network.network_type.identifier != "p":
                    raise ValidationError("master network must be a production network")
        # validate IP
        ip_dict = {
            key: None for key in ["network", "netmask", "broadcast", "gateway"]
        }
        for key in list(ip_dict.keys()):
            try:
                ip_dict[key] = ipvx_tools.IPv4(getattr(cur_inst, key))
            except:
                raise ValidationError("{} is not an IPv4 address".format(key))
        if not change_attr:
            change_attr = "network"
        if change_attr in ["network", "netmask"]:
            ip_dict["broadcast"] = ~ip_dict["netmask"] | (ip_dict["network"] & ip_dict["netmask"])
        elif change_attr == "broadcast":
            ip_dict["netmask"] = ~(ip_dict["broadcast"] & ~ip_dict["network"])
        elif change_attr == "gateway":
            # do nothing
            pass
        # check netmask
        _mask = 0
        any_match = False
        for _idx in range(32, -1, -1):
            if _mask == ip_dict["netmask"].value():
                any_match = True
                break
            _mask = _mask + 2 ** (_idx - 1)
        if not any_match:
            raise ValidationError("netmask is not valid")
        ip_dict["network"] = ip_dict["network"] & ip_dict["netmask"]
        # always correct gateway
        ip_dict["gateway"] = (ip_dict["gateway"] & ~ip_dict["netmask"]) | ip_dict["network"]
        if cur_inst._pre_enforce_unique_ips != cur_inst.enforce_unique_ips and cur_inst.enforce_unique_ips:
            ip_dict = {}
            for _ip in cur_inst.net_ip_set.all():
                ip_dict.setdefault(_ip.ip, []).append(_ip)
            ip_dict = {
                key: value for key, value in ip_dict.items() if len(value) > 1
            }
            if ip_dict:
                raise ValidationError(
                    "not all IPs are unique: {}".format(
                        ", ".join(
                            [
                                "{}: used {}".format(
                                    _key,
                                    logging_tools.get_plural("time", len(_value)),
                                ) for _key, _value in ip_dict.items()
                            ]
                        )
                    )
                )
        # check range
        _ignore_range = {None, "", "0.0.0.0"}
        if cur_inst.start_range not in _ignore_range and cur_inst.end_range not in _ignore_range:
            # validate range
            try:
                ip_dict["start_range"] = ipvx_tools.IPv4(cur_inst.start_range)
                ip_dict["end_range"] = ipvx_tools.IPv4(cur_inst.end_range)
            except:
                raise ValidationError(
                    "start / end range {} / {} not valid".format(
                        cur_inst.start_range,
                        cur_inst.end_range,
                    )
                )
            else:
                if ip_dict["end_range"] < ip_dict["start_range"]:
                    raise ValidationError(
                        "range end {} is below range start {}".format(
                            str(ip_dict["end_range"]),
                            str(ip_dict["start_range"]),
                        )
                    )
                if ip_dict["start_range"] <= ip_dict["network"]:
                    raise ValidationError(
                        "range start {} is less or equal to network {}".format(
                            str(ip_dict["end_range"]),
                            str(ip_dict["network"]),
                        )
                    )
                _highest = ip_dict["network"] | (ip_dict["broadcast"] & ~ip_dict["netmask"])
                if ip_dict["end_range"] >= _highest:
                    raise ValidationError(
                        "range end {} is above or equal to highest IP {}".format(
                            str(ip_dict["end_range"]),
                            str(_highest),
                        )
                    )
        # set values
        for key, value in ip_dict.items():
            setattr(cur_inst, key, str(value))


class net_ip(models.Model):
    idx = models.AutoField(db_column="netip_idx", primary_key=True)
    ip = models.CharField(max_length=48)
    network = models.ForeignKey("backbone.network")
    netdevice = models.ForeignKey("backbone.netdevice")
    penalty = models.IntegerField(default=0, verbose_name="cost")
    alias = models.CharField(max_length=765, blank=True, default="")
    alias_excl = models.NullBooleanField(null=True, blank=True, default=False)
    domain_tree_node = models.ForeignKey("backbone.domain_tree_node", null=True, default=None)
    date = models.DateTimeField(auto_now_add=True)

    def copy(self):
        return net_ip(
            ip=self.ip,
            network=self.network,
            penalty=self.penalty,
            alias=self.alias,
            alias_excl=self.alias_excl,
            domain_tree_node=self.domain_tree_node,
        )

    def get_hex_ip(self):
        return "".join(["%02X" % (int(part)) for part in self.ip.split(".")])

    def __str__(self):
        return self.ip

    @property
    def full_name(self):
        if not self.domain_tree_node_id:
            self.domain_tree_node = apps.get_model("backbone", "domain_tree_node").objects.get(Q(depth=0))
            self.save()
        if self.domain_tree_node.full_name:
            return ".".join([self.netdevice.device.name, self.domain_tree_node.full_name])
        else:
            return self.netdevice.device.name

    @property
    def is_unique(self):
        _valid = True
        if self.network.enforce_unique_ips:
            try:
                present_ip = net_ip.objects.exclude(Q(pk=self.pk)).get(Q(network=self.network) & Q(ip=self.ip))
            except net_ip.DoesNotExist:
                pass
            except net_ip.MultipleObjectsReturned:
                _valid = False
            else:
                _valid = False
        return _valid

    class Meta:
        db_table = "netip"
        verbose_name = "IP address"


@receiver(signals.pre_save, sender=net_ip)
def net_ip_pre_save(sender, **kwargs):
    if "instance" in kwargs:
        cur_inst = kwargs["instance"]
        try:
            ipv_addr = ipvx_tools.IPv4(cur_inst.ip)
        except:
            raise ValidationError("not a valid IPv4 address")
        if not cur_inst.network_id:
            match_list = ipv_addr.find_matching_network(network.objects.all())
            if len(match_list):
                cur_inst.network = match_list[0][1]
        if not cur_inst.network_id:
            _cs = config_store.ConfigStore(GEN_CS_NAME, quiet=True)
            if _cs["create.default.network"]:
                try:
                    default_nw = network.objects.get(Q(network="0.0.0.0"))
                except network.DoesNotExist:
                    default_nw = network.objects.create(
                        network="0.0.0.0",
                        netmask="0.0.0.0",
                        broadcast="255.255.255.255",
                        gateway="0.0.0.0",
                        identifier="all",
                        network_type=network_type.objects.get(Q(identifier="o"))
                    )
                cur_inst.network = default_nw
            else:
                raise NoMatchingNetworkFoundError("nothing found for '{}'".format(cur_inst.ip))
        if not ipv_addr.network_matches(cur_inst.network):
            match_list = ipv_addr.find_matching_network(network.objects.all())
            if match_list:
                cur_inst.network = match_list[0][1]
            else:
                raise NoMatchingNetworkFoundError("nothing found for '{}'".format(cur_inst.ip))
        dev_ips = net_ip.objects.exclude(
            Q(pk=cur_inst.pk)
        ).filter(
            Q(netdevice__device=cur_inst.netdevice.device)
        ).values_list(
            "ip",
            "network_id"
        )
        if (cur_inst.ip, cur_inst.network_id) in dev_ips:
            raise ValidationError(
                "Address {} already used, device {}".format(
                    cur_inst.ip,
                    str(cur_inst.netdevice.device)
                )
            )
        if cur_inst.network.enforce_unique_ips:
            try:
                present_ip = net_ip.objects.exclude(Q(pk=cur_inst.pk)).get(Q(network=cur_inst.network) & Q(ip=cur_inst.ip))
            except net_ip.DoesNotExist:
                pass
            except net_ip.MultipleObjectsReturned:
                raise ValidationError(
                    "IP already used more than once in network (force_unique_ips == True)"
                )
            else:
                raise ValidationError(
                    "IP already used for {} (enforce_unique_ips == True)".format(
                        str(present_ip.netdevice.device)
                    )
                )


@receiver(signals.pre_delete, sender=net_ip)
def net_ip_pre_delete(sender, **kwargs):
    if "instance" in kwargs:
        cur_inst = kwargs["instance"]
        if cur_inst.network.network_type.identifier == "b":
            cur_dev = cur_inst.netdevice.device
            if cur_inst.netdevice == cur_dev.bootnetdevice:
                # remove bootnetdevice
                cur_dev.bootnetdevice = None
                cur_dev.save(update_fields=["bootnetdevice"])


@receiver(signals.post_save, sender=net_ip)
def net_ip_post_save(sender, **kwargs):
    cur_inst = kwargs["instance"]
    if kwargs["created"] and not kwargs["raw"] and "instance" in kwargs:
        if cur_inst.ip == "127.0.0.1" and kwargs["created"] and not cur_inst.alias.strip():
            cur_inst.alias = "localhost"
            cur_inst.alias_excl = True
            cur_inst.save()
    if not kwargs["raw"]:
        if cur_inst.network.network_type.identifier == "b":
            # check for single boot IP
            num_boot_ips = net_ip.objects.filter(Q(network__network_type__identifier="b") & Q(netdevice__device=cur_inst.netdevice.device)).count()
            # set boot netdevice
            cur_inst.netdevice.device.bootnetdevice = cur_inst.netdevice
            cur_inst.netdevice.device.save()
            # currently there is no easy way to prevent adding more than one Boot-IPs, just let it happen and report an error
            # if num_boot_ips > 1:
            #    _dev_configs = cur_inst.netdevice.device.device_config_set.all().select_related("config")
            #    _names = [_dev_config.config.name for _dev_config in _dev_configs]
            #    if "server" in _names:
            #        # server, ignore multiple IP-adresses
            #        pass
            #    else:
            #        raise ValidationError("too many IP-adresses in a boot network defined")
            if cur_inst.netdevice.device.bootserver_id:
                BootsettingsChanged.send(sender=cur_inst, device=cur_inst.netdevice.device, cause="net_ip_changed")
        if cur_inst.netdevice.device.bootserver_id:
            BootsettingsChanged.send(sender=cur_inst, device=cur_inst.netdevice.device, cause="netdevice_changed")


class NetDeviceDesiredStateEnum(Enum):
    ignore = "i"
    up = "u"
    down = "d"


class NetDeviceSNMPMonOptions(object):
    def __init__(self, in_str):
        self.desired_status = NetDeviceDesiredStateEnum.ignore
        self.ignore_netdevice_speed = False
        _parts = in_str.strip().split(":")
        for _part in _parts:
            if _part.strip():
                _type = _part[0]
                if _type == "d":
                    self.desired_status = NetDeviceDesiredStateEnum(_part[1:])
                elif _type == "s":
                    self.ignore_netdevice_speed = True if int(_part[1]) else False

    @staticmethod
    def flags_to_str(obj):
        return "d{}:s{}".format(
            obj.desired_status,
            "1" if obj.ignore_netdevice_speed else "0"
        )


class netdevice(models.Model):
    idx = models.AutoField(db_column="netdevice_idx", primary_key=True)
    device = models.ForeignKey("backbone.device")
    devname = models.CharField(max_length=64)
    macaddr = models.CharField(db_column="macadr", max_length=177, blank=True, default="")
    driver_options = models.CharField(max_length=672, blank=True)
    # speed is probably deprecated, use netdevice_speed instead
    speed = models.BigIntegerField(default=0, null=True, blank=True)
    netdevice_speed = models.ForeignKey("backbone.netdevice_speed")
    ignore_netdevice_speed = models.BooleanField(default=False)
    driver = models.CharField(max_length=384, blank=True, default="e1000e")
    # is a valid routing target
    routing = models.BooleanField(default=False)
    # inter-device routing enabled
    inter_device_routing = models.BooleanField(default=True)
    penalty = models.IntegerField(null=True, blank=True, default=1, verbose_name="cost")
    dhcp_device = models.NullBooleanField(null=True, blank=True, default=False)
    ethtool_options = models.IntegerField(null=True, blank=True, default=0)
    fake_macaddr = models.CharField(db_column="fake_macadr", max_length=177, blank=True, default="")
    network_device_type = models.ForeignKey("backbone.network_device_type")
    description = models.CharField(max_length=765, blank=True)
    # true for bridge master
    is_bridge = models.BooleanField(default=False)
    # true for bond master
    is_bond = models.BooleanField(default=False)
    bridge_device = models.ForeignKey("self", null=True, blank=True, related_name="bridge_slaves")
    bond_master = models.ForeignKey("self", null=True, blank=True, related_name="bond_slaves")
    bridge_name = models.CharField(max_length=765, blank=True)
    vlan_id = models.IntegerField(null=True, blank=True, default=0)
    # for VLAN devices
    master_device = models.ForeignKey("self", null=True, related_name="vlan_slaves", blank=True)
    # enabled for monitoring
    enabled = models.BooleanField(default=True)
    date = models.DateTimeField(auto_now_add=True)
    # maximum transfer unit
    mtu = models.IntegerField(default=1500)
    # snmp related fields, zero for non-SNMP fetched network devices
    snmp_idx = models.IntegerField(default=0)
    # force matching the network device types, defaults to True
    # also affects MAC-address matching
    force_network_device_type_match = models.BooleanField(default=True)
    # snmp network type
    snmp_network_type = models.ForeignKey("backbone.snmp_network_type", null=True, blank=True)
    # admin / oper stats
    snmp_admin_status = models.IntegerField(default=0)
    snmp_oper_status = models.IntegerField(default=0)
    # desired status
    desired_status = models.CharField(
        max_length=4,
        default=NetDeviceDesiredStateEnum.ignore.value,
        choices=[(_en.value, _en.name) for _en in NetDeviceDesiredStateEnum]
    )
    # wmi interface index, only set if device is scanned using wmi
    # https://msdn.microsoft.com/en-us/library/aa394217(v=vs.85).aspx
    wmi_interface_index = models.IntegerField(default=None, null=True, blank=True)

    def __init__(self, *args, **kwargs):
        models.Model.__init__(self, *args, **kwargs)
        self.saved_values = {
            "penalty": self.penalty,
            "routing": self.routing,
        }

    def copy(self):
        return netdevice(
            devname=self.devname,
            macaddr=self.get_dummy_macaddr(),
            driver_options=self.driver_options,
            inter_device_routing=self.inter_device_routing,
            speed=self.speed,
            netdevice_speed=self.netdevice_speed,
            driver=self.driver,
            routing=self.routing,
            penalty=self.penalty,
            dhcp_device=self.dhcp_device,
            ethtool_options=self.ethtool_options,
            fake_macaddr=self.get_dummy_macaddr(),
            network_device_type=self.network_device_type,
            description=self.description,
            is_bridge=self.is_bridge,
            is_bond=self.is_bond,
            bridge_name=self.bridge_name,
            vlan_id=self.vlan_id,
            enabled=self.enabled,
            mtu=self.mtu,
            snmp_idx=self.snmp_idx,
            force_network_device_type_match=self.force_network_device_type_match,
            snmp_network_type=self.snmp_network_type,
            snmp_admin_status=self.snmp_admin_status,
            snmp_oper_status=self.snmp_oper_status,
            desired_status=self.desired_status,
            wmi_interface_index=self.wmi_interface_index,
            # hm ...
            # bridge_device=self.bridge_device,
        )

    def find_matching_network_device_type(self):
        match_list = [ndt for ndt in network_device_type.objects.filter(Q(for_matching=True)) if ndt.match(self.devname)]
        if len(match_list) == 0:
            return None
        elif len(match_list) == 1:
            return match_list[0]
        else:
            # take ndt with shortest name_re
            return sorted([(len(ndt.name_re), ndt) for ndt in match_list])[0][1]

    def get_dummy_macaddr(self):
        return ":".join(["00"] * self.network_device_type.mac_bytes)

    class ICSW_Meta:
        fk_ignore_list = ["net_ip", "peer_information"]

    class Meta:
        db_table = 'netdevice'
        ordering = ("snmp_idx", "devname",)
        verbose_name = "Netdevice"

    def delete(self, *args, **kwargs):
        super(netdevice, self).delete(*args, **kwargs)

    @property
    def ethtool_autoneg(self):
        return (self.ethtool_options or 0) & 3

    @property
    def ethtool_duplex(self):
        return ((self.ethtool_options or 0) >> 2) & 3

    @property
    def ethtool_speed(self):
        return ((self.ethtool_options or 0) >> 4) & 7

    @ethtool_autoneg.setter
    def ethtool_autoneg(self, in_val):
        self.ethtool_options = ((self.ethtool_options or 0) & ~3) | int(in_val)

    @ethtool_duplex.setter
    def ethtool_duplex(self, in_val):
        self.ethtool_options = ((self.ethtool_options or 0) & ~12) | (int(in_val) << 2)

    @ethtool_speed.setter
    def ethtool_speed(self, in_val):
        self.ethtool_options = ((self.ethtool_options or 0) & 15) | (int(in_val) << 4)

    def ethtool_string(self):
        return ",".join(["FIXME", "ethool_string()"])

    def __str__(self):
        return self.devname


@receiver(signals.pre_delete, sender=netdevice)
def netdevice_pre_delete(sender, **kwargs):
    pass


@receiver(signals.pre_save, sender=netdevice)
def netdevice_pre_save(sender, **kwargs):
    if "instance" in kwargs:
        cur_inst = kwargs["instance"]
        if cur_inst.devname:
            cur_inst.devname = cur_inst.devname[:63]
        check_empty_string(cur_inst, "devname")
        check_integer(cur_inst, "mtu", min_val=0, max_val=65536)
        all_nd_names = netdevice.objects.exclude(
            Q(pk=cur_inst.pk)
        ).filter(
            Q(device=cur_inst.device_id)
        ).values_list(
            "devname",
            flat=True
        )
        if cur_inst.devname in all_nd_names:
            raise ValidationError("devname '{}' already used".format(cur_inst.devname))
        # change network_device_type
        _cur_nw_type = cur_inst.network_device_type_id
        if cur_inst.force_network_device_type_match:
            nd_type = cur_inst.find_matching_network_device_type()
            if nd_type is not None:
                cur_inst.network_device_type = nd_type
            else:
                _cs = config_store.ConfigStore(GEN_CS_NAME, quiet=True)
                if _cs["create.network.device.types"]:
                    cur_inst.network_device_type = network_device_type.create_new_type(cur_inst)
                else:
                    raise NoMatchingNetworkDeviceTypeFoundError(
                        "nothing found for '{}' ({})".format(
                            str(cur_inst),
                            cur_inst.pk or "new nd"
                        )
                    )
        else:
            if not cur_inst.network_device_type_id:
                # take the first one which is not used for matching
                cur_inst.network_device_type = network_device_type.objects.filter(Q(for_matching=False))[0]
        _nw_type_changed = _cur_nw_type != cur_inst.network_device_type_id
        # fix None as vlan_id
        check_integer(cur_inst, "vlan_id", none_to_zero=True, min_val=0)
        # penalty
        check_integer(cur_inst, "penalty", min_val=1)
        # mac address matching (if needed)
        if cur_inst.force_network_device_type_match:
            # check mac address
            if cur_inst.macaddr:
                cur_inst.macaddr = cur_inst.macaddr.replace("-", ":").lower()
            if cur_inst.fake_macaddr:
                cur_inst.fake_macaddr = cur_inst.fake_macaddr.replace("-", ":").lower()
            dummy_mac, mac_re_str = (
                ":".join(
                    [
                        "00"
                    ] * cur_inst.network_device_type.mac_bytes
                ),
                "^{}$".format(
                    ":".join(
                        [
                            "[0-9a-f]{2}"
                        ] * cur_inst.network_device_type.mac_bytes
                    )
                ),
            )
            mac_re = re.compile(mac_re_str)
            # set empty if not set
            try:
                try:
                    if not cur_inst.macaddr.strip() or int(cur_inst.macaddr.replace(":", ""), 16) == 0:
                        cur_inst.macaddr = dummy_mac
                except:
                    raise ValidationError("MACaddress '{}' has illegal format".format(cur_inst.macaddr))
                # set empty if not set
                try:
                    if not cur_inst.fake_macaddr.strip() or int(cur_inst.fake_macaddr.replace(":", ""), 16) == 0:
                        cur_inst.fake_macaddr = dummy_mac
                except:
                    raise ValidationError("fake MACaddress '{}' has illegal format".format(cur_inst.fake_macaddr))
                if not mac_re.match(cur_inst.macaddr):
                    raise ValidationError("MACaddress '{}' has illegal format for RE '{}'".format(cur_inst.macaddr, mac_re_str))
                if not mac_re.match(cur_inst.fake_macaddr):
                    raise ValidationError("fake MACaddress '{}' has illegal format".format(cur_inst.fake_macaddr))
            except ValidationError:
                if _nw_type_changed:
                    raise ValidationError("NetworkDeviceType has changed and so the MAC-format has changed to '{}'".format(dummy_mac))
                else:
                    raise
        if cur_inst.master_device_id:
            if not cur_inst.vlan_id:
                raise ValidationError("VLAN id cannot be zero")
            if cur_inst.master_device_id == cur_inst.pk:
                raise ValidationError("cannot be my own VLAN master")
            if cur_inst.master_device.master_device_id:
                raise ValidationError("cannot chain VLAN devices")

        if cur_inst.netdevice_speed_id is None:
            # set a default
            cur_inst.netdevice_speed = netdevice_speed.objects.get(Q(speed_bps=1000000000) & Q(full_duplex=True) & Q(check_via_ethtool=False))
        # if cur_inst.vlan_id and not cur_inst.master_device_id:
        #    raise ValidationError("need a VLAN master")


@receiver(signals.post_save, sender=netdevice)
def netdevice_post_save(sender, **kwargs):
    if "instance" in kwargs:
        _cur_inst = kwargs["instance"]
        if _cur_inst.device.bootserver_id:
            BootsettingsChanged.send(sender=_cur_inst, device=_cur_inst.device, cause="netdevice update")


@receiver(signals.post_delete, sender=netdevice)
def netdevice_post_delete(sender, **kwargs):
    if "instance" in kwargs:
        _cur_inst = kwargs["instance"]


class netdevice_speed(models.Model):
    idx = models.AutoField(db_column="netdevice_speed_idx", primary_key=True)
    speed_bps = models.BigIntegerField(null=True, blank=True)
    check_via_ethtool = models.BooleanField(default=True)
    full_duplex = models.BooleanField(default=True)
    date = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = 'netdevice_speed'
        ordering = ("speed_bps", "full_duplex")

    def info_string(self):
        return str(self)

    @staticmethod
    def build_lut():
        speed_dict = {}
        for _entry in netdevice_speed.objects.all().order_by("-check_via_ethtool", "-full_duplex"):
            if _entry.speed_bps not in speed_dict:
                speed_dict[_entry.speed_bps] = _entry
        return speed_dict

    def __str__(self):
        if self.speed_bps:
            _s_str, lut_idx = ("", 0)
            cur_s = self.speed_bps
            while cur_s > 999:
                cur_s = cur_s / 1000
                lut_idx += 1
            _speed_str = "{}{}Bps".format(
                cur_s,
                " kMGT"[lut_idx].strip()
            )
        else:
            _speed_str = "unspec."
        return "{}, {} duplex, {}".format(
            _speed_str,
            "full" if self.full_duplex else "half",
            "check via ethtool" if self.check_via_ethtool else "no check"
        )


@receiver(signals.pre_save, sender=network_type)
def network_type_pre_save(sender, **kwargs):
    if "instance" in kwargs:
        cur_inst = kwargs["instance"]
        # raise ValidationError("test validation error")
        if not(cur_inst.identifier.strip()):
            raise ValidationError("identifer must not be empty")

# new peer models, not in use right now

"""
class NetworkPeerType(models.Model):
    # network peer type model
    idx = models.AutoField(primary_key=True)
    name = models.CharField(max_length=128, unique=True, default="")
    description = models.CharField(max_length=255, default="")
    # is a physical peertype
    physical = models.BooleanField(default=True)
    date = models.DateTimeField(auto_now_add=True)


class NetworkPeer(models.Model):
    # new network peer information model
    idx = models.AutoField(primary_key=True)
    source_netdevice = models.ForeignKey("backbone.netdevice", related_name="network_peer_source")
    source_spec = models.CharField(default="", max_length=128, verbose_name="source spec", blank=True)
    dest_netdevice = models.ForeignKey("backbone.netdevice", related_name="network_peer_dest")
    dest_spec = models.CharField(default="", max_length=128, verbose_name="destination spec", blank=True)
    # need at least penalty 1
    penalty = models.IntegerField(default=1, verbose_name="cost")
    # true for peers created via SNMP or another automatic process
    autocreated = models.BooleanField(default=False)
    # create user
    create_user = models.ForeignKey("backbone.user", null=True)
    info = models.CharField(default="", max_length=256, blank=True)
    peer_type = models.ForeignKey("backbone.NetworkPeerType")
    date = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return u"{} [{:d}] {}".format(
            self.source_netdevice.devname,
            self.penalty,
            self.dest_netdevice.devname
        )
"""


class peer_information(models.Model):
    idx = models.AutoField(db_column="peer_information_idx", primary_key=True)
    s_netdevice = models.ForeignKey("backbone.netdevice", related_name="peer_s_netdevice")
    s_spec = models.CharField(default="", max_length=128, verbose_name="source spec", blank=True)
    d_netdevice = models.ForeignKey("backbone.netdevice", related_name="peer_d_netdevice")
    d_spec = models.CharField(default="", max_length=128, verbose_name="dest spec", blank=True)
    penalty = models.IntegerField(default=0, verbose_name="cost")
    # true for peers created via SNMP
    autocreated = models.BooleanField(default=False)
    info = models.CharField(default="", max_length=256, blank=True)
    date = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return "{} [{:d}] {}".format(
            self.s_netdevice.devname,
            self.penalty,
            self.d_netdevice.devname
        )

    def get_s_device(self):
        return self.s_netdevice.device_id

    def get_d_device(self):
        return self.d_netdevice.device_id

    def store_before_delete(self, del_device):
        if self.s_netdevice.device_id == del_device.pk:
            other_nd = self.d_netdevice
            other_spec = self.d_spec
            my_name = self.s_netdevice.devname
            my_spec = self.s_spec
        else:
            other_nd = self.s_netdevice
            other_spec = self.s_spec
            my_name = self.d_netdevice.devname
            my_spec = self.d_spec
        return {
            "s_spec": self.s_spec,
            "penalty": self.penalty,
            "autocreated": self.autocreated,
            "info": self.info,
            "other_netdevice": other_nd,
            "my_name": my_name,
            "my_spec": my_spec,
            "other_spec": other_spec,
        }

    @staticmethod
    def create_from_store(peer_dict, new_nd):
        return peer_information.objects.create(
            s_netdevice=new_nd,
            s_spec=peer_dict["my_spec"],
            d_netdevice=peer_dict["other_netdevice"],
            d_spec=peer_dict["other_spec"],
            penalty=peer_dict["penalty"],
            autocreated=peer_dict["autocreated"],
            info=peer_dict["info"],
        )

    class Meta:
        db_table = 'peer_information'
        verbose_name = "Peer information"


@receiver(signals.pre_save, sender=peer_information)
def peer_information_pre_save(sender, **kwargs):
    if "instance" in kwargs:
        cur_inst = kwargs["instance"]
        try:
            _cur_peer = peer_information.objects.get(
                (
                    Q(s_netdevice=cur_inst.s_netdevice_id) &
                    Q(d_netdevice=cur_inst.d_netdevice_id)
                ) | (
                    Q(s_netdevice=cur_inst.d_netdevice_id) &
                    Q(d_netdevice=cur_inst.s_netdevice_id)
                )
            )
        except peer_information.DoesNotExist:
            pass
        else:
            if _cur_peer.pk != cur_inst.pk:
                raise ValidationError(
                    "peer already exists [{} on {} --- {} on {}]".format(
                        cur_inst.s_netdevice.devname,
                        str(cur_inst.s_netdevice.device),
                        cur_inst.d_netdevice.devname,
                        str(cur_inst.d_netdevice.device),
                    )
                )
        check_integer(cur_inst, "penalty", min_val=1)


@receiver(signals.post_save, sender=peer_information)
def peer_information_post_save(sender, **kwargs):
    if not kwargs["raw"] and "instance" in kwargs:
        _cur_inst = kwargs["instance"]


@receiver(signals.post_delete, sender=peer_information)
def peer_information_post_delete(sender, **kwargs):
    if "instance" in kwargs:
        _cur_inst = kwargs["instance"]


class snmp_network_type(models.Model):
    idx = models.AutoField(primary_key=True)
    if_type = models.IntegerField(default=0)
    if_label = models.CharField(max_length=128, default="")
    description = models.CharField(max_length=256, default="")
    regex = models.CharField(max_length=64, default="")
    # number of bytes in macaddress
    mac_bytes = models.PositiveIntegerField(default=6)
    date = models.DateTimeField(auto_now_add=True)


class NmapDevice(object):
    def __init__(self, ip, mac, hostname, ignored):
        self.ip = ip
        self.mac = mac
        self.hostname = hostname
        self.ignored = ignored
        self.first_seen_nmap_scan_idx = None
        self.first_seen_nmap_scan_date = None

    def get_dict(self):
        return {
            'ip': self.ip,
            'mac': self.mac,
            'hostname': self.hostname,
            'ignored': self.ignored,
            'first_seen_nmap_scan_idx': self.first_seen_nmap_scan_idx,
            'first_seen_nmap_scan_date': self.first_seen_nmap_scan_date
        }

    def __eq__(self, other):
        return self.ip == other.ip and self.mac == other.mac and self.hostname == other.hostname


class NmapScan(models.Model):
    idx = models.AutoField(primary_key=True)

    date = models.DateTimeField(auto_now_add=True)

    network = models.ForeignKey("backbone.network")

    raw_result = models.TextField(null=True)

    runtime = models.FloatField(null=True)

    devices_found = models.IntegerField(null=True)

    devices_scanned = models.IntegerField(null=True)

    devices_ignored = models.IntegerField(null=True)

    error_string = models.TextField(null=True)

    in_progress = models.BooleanField(default=True)

    manual_scan = models.BooleanField(default=False)

    def initialize(self, raw_result=raw_result):
        parser = etree.XMLParser(encoding='utf-8')

        root = etree.fromstring(raw_result.encode('utf-8'), parser=parser)

        runstats_element = root.find("runstats")
        finished_element = runstats_element.find("finished")

        runtime = float(finished_element.attrib["elapsed"])

        hosts_element = runstats_element.find("hosts")
        devices_found = int(hosts_element.attrib["up"])
        devices_scanned = int(hosts_element.attrib["total"])

        self.raw_result = raw_result
        self.runtime = runtime
        self.devices_found = devices_found
        self.devices_scanned = devices_scanned

        self.reset_devices_ignored()

    def reset_devices_ignored(self):
        self.devices_ignored = len([_device for _device in self.get_nmap_devices() if _device.ignored])

    @classmethod
    def create(cls, network=network, manual_scan=False):
        return cls(network=network, manual_scan=manual_scan)

    def get_nmap_devices(self):
        devices = []

        if self.raw_result:
            parser = etree.XMLParser(encoding='utf-8')

            root = etree.fromstring(self.raw_result.encode('utf-8'), parser=parser)

            ignored_macs = [nsid.mac for nsid in NmapScanIgnoredDevice.objects.all()]

            for host in root.findall('host'):
                status_element = host.find("status")
                if status_element.attrib["state"] == "down":
                    continue

                mac = None
                ipv4 = None
                hostname = None
                for address in host.findall('address'):
                    if address.attrib['addrtype'] == 'mac':
                        mac = address.attrib['addr']
                    elif address.attrib['addrtype'] == 'ipv4':
                        ipv4 = address.attrib['addr']

                hostnames = host.find('hostnames')
                for hostname_elem in hostnames.findall('hostname'):
                    hostname = hostname_elem.attrib['name']

                if ipv4:
                    devices.append(NmapDevice(ipv4, mac, hostname, mac in ignored_macs))

        return devices

    @property
    def matrix(self):
        """ Returns a matrix like representation of the device/host availability for this nmap scan.
        """
        parser = etree.XMLParser(encoding='utf-8')

        root = etree.fromstring(self.raw_result.encode('utf-8'), parser=parser)

        ignored_macs = [nsid.mac for nsid in NmapScanIgnoredDevice.objects.all()]

        all_devices = device.objects.all()
        ip_to_device_lut = {}
        for _device in all_devices:
            for ip in _device.all_ips():
                ip_to_device_lut[ip] = _device

        found_hosts = {}

        # presort by ip
        for host in root.findall('host'):
            for address in host.findall('address'):
                if address.attrib['addrtype'] == 'ipv4':
                    ipv4 = address.attrib['addr']

                    a, b, c, d = ipv4.split(".")
                    a, b, c, d = int(a), int(b), int(c), int(d)

                    if a not in found_hosts:
                        found_hosts[a] = {}

                    if b not in found_hosts[a]:
                        found_hosts[a][b] = {}

                    if c not in found_hosts[a][b]:
                        found_hosts[a][b][c] = {}

                    if d not in found_hosts[a][b][c]:
                        found_hosts[a][b][c][d] = {}

                    found_hosts[a][b][c][d] = host

        matrix_element_counter = 0
        matrix_rows = []
        current_matrix_row = None
        num_matrix_rows_columns = int(math.sqrt(float(self.devices_scanned)))

        for a in sorted(found_hosts.keys()):
            for b in sorted(found_hosts[a].keys()):
                for c in sorted(found_hosts[a][b].keys()):
                    for d in sorted(found_hosts[a][b][c].keys()):
                        ipv4 = "{}.{}.{}.{}".format(a, b, c, d)
                        host = found_hosts[a][b][c][d]

                        if (matrix_element_counter % num_matrix_rows_columns) == 0:
                            current_matrix_row = []
                            matrix_rows.append(current_matrix_row)

                        matrix_element_counter += 1

                        status_element = host.find("status")

                        matrix_class = ""
                        if status_element.attrib["state"] != "down":
                            mac = None
                            for address in host.findall('address'):
                                if address.attrib['addrtype'] == 'mac':
                                    mac = address.attrib['addr']
                                    break

                            if ipv4 and ipv4 in ip_to_device_lut:
                                matrix_class = "alert-success"
                            else:
                                matrix_class = "alert-danger"

                            if mac in ignored_macs:
                                matrix_class = "alert-warning"

                        current_matrix_row.append((ipv4, matrix_class))

        while len(current_matrix_row) < num_matrix_rows_columns:
            current_matrix_row.append(("N/A", ""))

        return matrix_rows


class NmapScanIgnoredDevice(models.Model):
    idx = models.AutoField(primary_key=True)

    mac = models.CharField(max_length=17, unique=True)


@receiver(signals.post_save, sender=NmapScan)
def nmap_scan_post_save(sender, **kwargs):
    _ = sender
    if "instance" in kwargs:
        from initat.cluster.backbone.serializers import NmapScanSerializerSimple
        from initat.cluster.backbone.websockets.constants import WSStreamEnum

        cur_inst = kwargs["instance"]

        serializer = NmapScanSerializerSimple(cur_inst)

        propagate_channel_object(WSStreamEnum.nmap_scans, serializer.data)
