# Copyright (C) 2011-2016 Andreas Lang-Nevyjel, init.at
#
# Send feedback to: <lang-nevyjel@init.at>
#
# This file is part of cluster-backbone-sql
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License Version 2 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# -*- coding: utf-8 -*-
#

import logging
import re
from enum import Enum

from django.apps import apps
from django.core.exceptions import ValidationError
from django.db import models
from django.db.models import Q, signals
from django.dispatch import receiver

from initat.cluster.backbone.exceptions import NoMatchingNetworkFoundError, \
    NoMatchingNetworkDeviceTypeFoundError
from initat.cluster.backbone.models.functions import check_empty_string, \
    check_integer
from initat.cluster.backbone.signals import BootsettingsChanged
from initat.constants import GEN_CS_NAME
from initat.tools import ipvx_tools, logging_tools, process_tools, config_store

__all__ = [
    "network",
    "network_type",
    "net_ip",
    "network_device_type",
    "netdevice",
    "netdevice_speed",
    "peer_information",
    "snmp_network_type",
    "NetDeviceDesiredStateEnum",
    "NetDeviceSNMPMonOptions",
]

logger = logging.getLogger(__name__)


class network_device_type(models.Model):
    idx = models.AutoField(db_column="network_device_type_idx", primary_key=True)
    identifier = models.CharField(unique=True, max_length=48, blank=False)
    name_re = models.CharField(max_length=128, default="^.*$")
    description = models.CharField(max_length=192)
    mac_bytes = models.PositiveIntegerField(default=6)
    allow_virtual_interfaces = models.BooleanField(default=True)
    # used for matching ?
    for_matching = models.BooleanField(default=True)
    auto_created = models.BooleanField(default=False)
    date = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = u'network_device_type'

    def match(self, devname):
        if self.allow_virtual_interfaces and devname.count(":") == 1:
            _m_name = devname.split(":")[0]
        else:
            _m_name = devname
        return re.match(self.name_re, _m_name)

    def info_string(self):
        return unicode(self)

    @staticmethod
    def create_new_type(ndev):
        new_re = "^{}$".format("\d+".join(re.split("\d+", ndev.devname)))
        if ndev.macaddr:
            mac_bytes = len(ndev.macaddr.replace(":", "").strip())
        else:
            mac_bytes = 6
        GN = "autogen-"
        gen_names = [
            _val for _val in network_device_type.objects.all().values_list("identifier", flat=True) if _val.startswith(GN)
        ]
        gen_idx = 0
        while True:
            gen_idx += 1
            new_name = "{}{:d}".format(GN, gen_idx)
            if new_name not in gen_names:
                break
        new_ndt = network_device_type(
            identifier=new_name,
            name_re=new_re,
            description="autogenerated from '{}'".format(ndev.devname),
            mac_bytes=mac_bytes,
            allow_virtual_interfaces=False,
            for_matching=True,
            auto_created=True,
        )
        new_ndt.save()
        return new_ndt

    def __unicode__(self):
        return u"{} ({} [{:d}])".format(
            self.identifier,
            self.description,
            self.mac_bytes
        )


@receiver(signals.post_init, sender=network_device_type)
def network_device_type_post_init(sender, **kwargs):
    if "instance" in kwargs:
        cur_inst = kwargs["instance"]
        # print "*" * 20, cur_inst.identifier, cur_inst.pk, "+" * 20
        if cur_inst.name_re == "^.*$" and cur_inst.pk and not cur_inst.for_matching:
            if cur_inst.identifier in ["lo"]:
                cur_inst.name_re = "^{}$".format(cur_inst.identifier)
            else:
                cur_inst.name_re = "^{}\d+$".format(cur_inst.identifier)
            cur_inst.save()


@receiver(signals.pre_save, sender=network_device_type)
def network_device_type_pre_save(sender, **kwargs):
    if "instance" in kwargs:
        cur_inst = kwargs["instance"]
        if not(cur_inst.identifier.strip()):
            raise ValidationError("identifer must not be empty")
        if not re.match("^[a-zA-Z0-9\-]+$", cur_inst.identifier):
            raise ValidationError("identifier '{}' contains illegal characters".format(cur_inst.identifier))
        if not cur_inst.name_re.startswith("^"):
            cur_inst.name_re = "^{}".format(cur_inst.name_re)
        if not cur_inst.name_re.endswith("$"):
            cur_inst.name_re = "{}$".format(cur_inst.name_re)
        try:
            _cur_re = re.compile(cur_inst.name_re)
        except:
            raise ValidationError(
                "invalid re '{}': {}".format(
                    cur_inst.name_re,
                    process_tools.get_except_info()
                )
            )
        check_integer(cur_inst, "mac_bytes", min_val=6, max_val=24)


class network_type(models.Model):
    idx = models.AutoField(db_column="network_type_idx", primary_key=True)
    identifier = models.CharField(
        unique=True, max_length=3,
        choices=(
            ("b", "boot"),
            ("p", "prod"),
            ("s", "slave"),
            ("o", "other"),
            ("l", "local")
        )
    )
    description = models.CharField(max_length=192, blank=False)
    date = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = u'network_type'

    def __unicode__(self):
        return u"{} ({})".format(
            self.description,
            self.identifier
        )


class _NetworkManager(models.Manager):
    def get_or_create_network(self, network_addr, netmask, gateway=None, context=None):
        """
        :type network_addr: ipvx_tools.ipv4
        :type netmask: ipvx_tools.ipv4
        :type gateway: ipvx_tools.ipv4 | None
        :param str context: string added to network name and info
        :rtype: network
        """
        try:
            cur_nw = self.get(Q(network=str(network_addr)) & Q(netmask=str(netmask)))
        except self.model.DoesNotExist:
            if str(network_addr).startswith("127."):
                _identifier = "l"
            else:
                _identifier = "o"
            info_str = " from {}".format(context) if context else ""
            gateway = str(gateway) if gateway else str(network_addr + ipvx_tools.ipv4("0.0.0.1"))
            cur_nw = self.model(
                network_type=network_type.objects.get(Q(identifier=_identifier)),
                short_names=False,
                identifier=network.get_unique_identifier(),
                name="autogenerated{}".format(info_str),
                info="autogenerated{}".format(info_str),
                network=str(network_addr),
                netmask=str(netmask),
                gateway=gateway,
                broadcast=str(~netmask | (network_addr & netmask)),
            )
            cur_nw.save()
        return cur_nw


class network(models.Model):
    objects = _NetworkManager()
    idx = models.AutoField(db_column="network_idx", primary_key=True)
    identifier = models.CharField(unique=True, max_length=255, blank=False)
    network_type = models.ForeignKey("network_type")
    master_network = models.ForeignKey("backbone.network", null=True, related_name="rel_master_network", blank=True)
    # should no longer be used, now in domain_tree_node
    short_names = models.BooleanField(default=True)
    # should no longer be used, now in domain_tree_node
    name = models.CharField(max_length=192, blank=True, default="")
    penalty = models.PositiveIntegerField(default=1, verbose_name="cost")
    # should no longer be used, now in domain_tree_node
    postfix = models.CharField(max_length=12, blank=True, default="")
    info = models.CharField(max_length=255, blank=True)
    network = models.GenericIPAddressField(blank=False)
    netmask = models.GenericIPAddressField(blank=False)
    broadcast = models.GenericIPAddressField(blank=False)
    gateway = models.GenericIPAddressField(blank=False)
    gw_pri = models.IntegerField(null=True, blank=True, default=1)
    # should no longer be used, now in domain_tree_node
    write_bind_config = models.BooleanField(default=False)
    # should no longer be used, now in domain_tree_node
    write_other_network_config = models.BooleanField(default=False)
    start_range = models.GenericIPAddressField(default="0.0.0.0")
    end_range = models.GenericIPAddressField(default="0.0.0.0")
    date = models.DateTimeField(auto_now_add=True)
    # preferred domain_tree_node
    preferred_domain_tree_node = models.ForeignKey("backbone.domain_tree_node", null=True, blank=True)
    network_device_type = models.ManyToManyField("backbone.network_device_type", blank=True)
    enforce_unique_ips = models.BooleanField(default=False)

    class CSW_Meta:
        permissions = (
            ("modify_network", "modify global network settings", False),
            ("show_clusters", "show network clustering", False),
        )

    def get_free_ip(self):
        _ignore_range = {None, "", "0.0.0.0"}
        free_ip = None
        if self.start_range not in _ignore_range and self.end_range not in _ignore_range:
            used_ips = {ipvx_tools.ipv4(_ip.ip) for _ip in self.net_ip_set.all()}
            offset = ipvx_tools.ipv4("0.0.0.1")
            free_ip = ipvx_tools.ipv4(self.start_range)
            while free_ip in used_ips:
                free_ip += offset
            if free_ip > ipvx_tools.ipv4(self.end_range):
                free_ip = None
        return free_ip

    @staticmethod
    def get_unique_identifier():
        _all_ids = network.objects.all().values_list("identifier", flat=True)
        gen_idx = 0
        while True:
            gen_idx += 1
            _name = "autogen{:d}".format(gen_idx)
            if _name not in _all_ids:
                break
        return _name

    def get_identifier(self):
        return self.network_type.identifier

    def get_type_name(self):
        return self.network_type.description

    def num_ip(self):
        return self.net_ip_set.all().count()

    class Meta:
        db_table = u'network'

    def get_info(self):
        all_slaves = self.rel_master_network.all()
        # return extended info
        log_str = "{} network '{}' has {}{}".format(
            self.network_type.get_identifier_display(),
            self.identifier,
            logging_tools.get_plural("slave network", len(all_slaves)),
            ": {}".format(
                [
                    cur_slave.identifier for cur_slave in all_slaves
                ]
            ) if all_slaves else "",
        )
        return log_str

    def info_string(self):
        return unicode(self)

    def __unicode__(self):
        return u"{} ({}/{}, {})".format(
            self.identifier,
            self.network,
            ipvx_tools.get_network_name_from_mask(self.netmask),
            self.network_type.identifier
        )


@receiver(signals.post_init, sender=network)
def network_post_init(sender, **kwargs):
    if "instance" in kwargs:
        cur_inst = kwargs["instance"]
        cur_inst._pre_enforce_unique_ips = cur_inst.enforce_unique_ips


@receiver(signals.pre_save, sender=network)
def network_pre_save(sender, **kwargs):
    if "instance" in kwargs:
        cur_inst = kwargs["instance"]
        # what was the changed attribute
        change_attr = getattr(cur_inst, "change_attribute", None)
        check_integer(cur_inst, "penalty", min_val=-100, max_val=100)
        nw_type = cur_inst.network_type.identifier
        if cur_inst.rel_master_network.all().count() and nw_type != "p":
            raise ValidationError("slave networks exists, cannot change type")
        if nw_type != "s" and cur_inst.master_network_id:
            raise ValidationError("only slave networks can have a master")
        if nw_type == "s":
            if not cur_inst.master_network_id:
                raise ValidationError("slave network needs a master network")
            else:
                # print cur_inst.pk, cur_inst.master_network_id
                if cur_inst.master_network.network_type.identifier != "p":
                    raise ValidationError("master network must be a production network")
        # validate IP
        ip_dict = {
            key: None for key in ["network", "netmask", "broadcast", "gateway"]
        }
        for key in ip_dict.keys():
            try:
                ip_dict[key] = ipvx_tools.ipv4(getattr(cur_inst, key))
            except:
                raise ValidationError("{} is not an IPv4 address".format(key))
        if not change_attr:
            change_attr = "network"
        if change_attr in ["network", "netmask"]:
            ip_dict["broadcast"] = ~ip_dict["netmask"] | (ip_dict["network"] & ip_dict["netmask"])
        elif change_attr == "broadcast":
            ip_dict["netmask"] = ~(ip_dict["broadcast"] & ~ip_dict["network"])
        elif change_attr == "gateway":
            # do nothing
            pass
        # check netmask
        _mask = 0
        any_match = False
        for _idx in xrange(32, -1, -1):
            if _mask == ip_dict["netmask"].value():
                any_match = True
                break
            _mask = _mask + 2 ** (_idx - 1)
        if not any_match:
            raise ValidationError("netmask is not valid")
        ip_dict["network"] = ip_dict["network"] & ip_dict["netmask"]
        # always correct gateway
        ip_dict["gateway"] = (ip_dict["gateway"] & ~ip_dict["netmask"]) | ip_dict["network"]
        if cur_inst._pre_enforce_unique_ips != cur_inst.enforce_unique_ips and cur_inst.enforce_unique_ips:
            ip_dict = {}
            for _ip in cur_inst.net_ip_set.all():
                ip_dict.setdefault(_ip.ip, []).append(_ip)
            ip_dict = {
                key: value for key, value in ip_dict.iteritems() if len(value) > 1
            }
            if ip_dict:
                raise ValidationError(
                    "not all IPs are unique: {}".format(
                        ", ".join(
                            [
                                "{}: used {}".format(
                                    _key,
                                    logging_tools.get_plural("time", len(_value)),
                                ) for _key, _value in ip_dict.iteritems()
                            ]
                        )
                    )
                )
        # check range
        _ignore_range = {None, "", "0.0.0.0"}
        if cur_inst.start_range not in _ignore_range and cur_inst.end_range not in _ignore_range:
            # validate range
            try:
                ip_dict["start_range"] = ipvx_tools.ipv4(cur_inst.start_range)
                ip_dict["end_range"] = ipvx_tools.ipv4(cur_inst.end_range)
            except:
                raise ValidationError(
                    "start / end range {} / {} not valid".format(
                        cur_inst.start_range,
                        cur_inst.end_range,
                    )
                )
            else:
                if ip_dict["end_range"] < ip_dict["start_range"]:
                    raise ValidationError(
                        "range end {} is below range start {}".format(
                            str(ip_dict["end_range"]),
                            str(ip_dict["start_range"]),
                        )
                    )
                if ip_dict["start_range"] <= ip_dict["network"]:
                    raise ValidationError(
                        "range start {} is less or equal to network {}".format(
                            str(ip_dict["end_range"]),
                            str(ip_dict["network"]),
                        )
                    )
                _highest = ip_dict["network"] | (ip_dict["broadcast"] & ~ip_dict["netmask"])
                if ip_dict["end_range"] >= _highest:
                    raise ValidationError(
                        "range end {} is above or equal to highest IP {}".format(
                            str(ip_dict["end_range"]),
                            str(_highest),
                        )
                    )
        # set values
        for key, value in ip_dict.iteritems():
            setattr(cur_inst, key, unicode(value))


class net_ip(models.Model):
    idx = models.AutoField(db_column="netip_idx", primary_key=True)
    ip = models.CharField(max_length=48)
    network = models.ForeignKey("backbone.network")
    netdevice = models.ForeignKey("backbone.netdevice")
    penalty = models.IntegerField(default=0, verbose_name="cost")
    alias = models.CharField(max_length=765, blank=True, default="")
    alias_excl = models.NullBooleanField(null=True, blank=True, default=False)
    domain_tree_node = models.ForeignKey("backbone.domain_tree_node", null=True, default=None)
    date = models.DateTimeField(auto_now_add=True)

    def copy(self):
        return net_ip(
            ip=self.ip,
            network=self.network,
            penalty=self.penalty,
            alias=self.alias,
            alias_excl=self.alias_excl,
            domain_tree_node=self.domain_tree_node,
        )

    def get_hex_ip(self):
        return "".join(["%02X" % (int(part)) for part in self.ip.split(".")])

    def __unicode__(self):
        return self.ip

    @property
    def full_name(self):
        if not self.domain_tree_node_id:
            self.domain_tree_node = apps.get_model("backbone", "domain_tree_node").objects.get(Q(depth=0))
            self.save()
        if self.domain_tree_node.full_name:
            return ".".join([self.netdevice.device.name, self.domain_tree_node.full_name])
        else:
            return self.netdevice.device.name

    @property
    def is_unique(self):
        _valid = True
        if self.network.enforce_unique_ips:
            try:
                present_ip = net_ip.objects.exclude(Q(pk=self.pk)).get(Q(network=self.network) & Q(ip=self.ip))
            except net_ip.DoesNotExist:
                pass
            except net_ip.MultipleObjectsReturned:
                _valid = False
            else:
                _valid = False
        return _valid

    class Meta:
        db_table = u"netip"
        verbose_name = "IP address"


@receiver(signals.pre_save, sender=net_ip)
def net_ip_pre_save(sender, **kwargs):
    if "instance" in kwargs:
        cur_inst = kwargs["instance"]
        try:
            ipv_addr = ipvx_tools.ipv4(cur_inst.ip)
        except:
            raise ValidationError("not a valid IPv4 address")
        if not cur_inst.network_id:
            match_list = ipv_addr.find_matching_network(network.objects.all())
            if len(match_list):
                cur_inst.network = match_list[0][1]
        if not cur_inst.network_id:
            _cs = config_store.ConfigStore(GEN_CS_NAME, quiet=True)
            if _cs["create.default.network"]:
                try:
                    default_nw = network.objects.get(Q(network="0.0.0.0"))
                except network.DoesNotExist:
                    default_nw = network.objects.create(
                        network="0.0.0.0",
                        netmask="0.0.0.0",
                        broadcast="255.255.255.255",
                        gateway="0.0.0.0",
                        identifier="all",
                        network_type=network_type.objects.get(Q(identifier="o"))
                    )
                cur_inst.network = default_nw
            else:
                raise NoMatchingNetworkFoundError("nothing found for '{}'".format(cur_inst.ip))
        if not ipv_addr.network_matches(cur_inst.network):
            match_list = ipv_addr.find_matching_network(network.objects.all())
            if match_list:
                cur_inst.network = match_list[0][1]
            else:
                raise NoMatchingNetworkFoundError("nothing found for '{}'".format(cur_inst.ip))
        dev_ips = net_ip.objects.exclude(
            Q(pk=cur_inst.pk)
        ).filter(
            Q(netdevice__device=cur_inst.netdevice.device)
        ).values_list(
            "ip",
            "network_id"
        )
        if (cur_inst.ip, cur_inst.network_id) in dev_ips:
            raise ValidationError(
                "Address {} already used, device {}".format(
                    cur_inst.ip,
                    unicode(cur_inst.netdevice.device)
                )
            )
        if cur_inst.network.enforce_unique_ips:
            try:
                present_ip = net_ip.objects.exclude(Q(pk=cur_inst.pk)).get(Q(network=cur_inst.network) & Q(ip=cur_inst.ip))
            except net_ip.DoesNotExist:
                pass
            except net_ip.MultipleObjectsReturned:
                raise ValidationError(
                    "IP already used more than once in network (force_unique_ips == True)"
                )
            else:
                raise ValidationError(
                    "IP already used for {} (enforce_unique_ips == True)".format(
                        unicode(present_ip.netdevice.device)
                    )
                )


@receiver(signals.pre_delete, sender=net_ip)
def net_ip_pre_delete(sender, **kwargs):
    cur_inst = kwargs["instance"]
    if "instance" in kwargs:
        cur_inst = kwargs["instance"]
        if cur_inst.network.network_type.identifier == "b":
            cur_dev = cur_inst.netdevice.device
            if cur_inst.netdevice == cur_dev.bootnetdevice:
                # remove bootnetdevice
                cur_dev.bootnetdevice = None
                cur_dev.save(update_fields=["bootnetdevice"])


@receiver(signals.post_save, sender=net_ip)
def net_ip_post_save(sender, **kwargs):
    cur_inst = kwargs["instance"]
    if kwargs["created"] and not kwargs["raw"] and "instance" in kwargs:
        if cur_inst.ip == "127.0.0.1" and kwargs["created"] and not cur_inst.alias.strip():
            cur_inst.alias = "localhost"
            cur_inst.alias_excl = True
            cur_inst.save()
    if not kwargs["raw"]:
        if cur_inst.network.network_type.identifier == "b":
            # check for single boot IP
            num_boot_ips = net_ip.objects.filter(Q(network__network_type__identifier="b") & Q(netdevice__device=cur_inst.netdevice.device)).count()
            # set boot netdevice
            cur_inst.netdevice.device.bootnetdevice = cur_inst.netdevice
            cur_inst.netdevice.device.save()
            if num_boot_ips > 1:
                _dev_configs = cur_inst.netdevice.device.device_config_set.all().select_related("config")
                _names = [_dev_config.config.name for _dev_config in _dev_configs]
                if "server" in _names:
                    # server, ignore multiple IP-adresses
                    pass
                else:
                    raise ValidationError("too many IP-adresses in a boot network defined")
            if cur_inst.netdevice.device.bootserver_id:
                BootsettingsChanged.send(sender=cur_inst, device=cur_inst.netdevice.device, cause="net_ip_changed")
        if cur_inst.netdevice.device.bootserver_id:
            BootsettingsChanged.send(sender=cur_inst, device=cur_inst.netdevice.device, cause="netdevice_changed")


class NetDeviceDesiredStateEnum(Enum):
    ignore = "i"
    up = "u"
    down = "d"


class NetDeviceSNMPMonOptions(object):
    def __init__(self, in_str):
        self.desired_status = NetDeviceDesiredStateEnum.ignore
        self.ignore_netdevice_speed = False
        _parts = in_str.strip().split(":")
        for _part in _parts:
            if _part.strip():
                _type = _part[0]
                if _type == "d":
                    self.desired_status = NetDeviceDesiredStateEnum(_part[1:])
                elif _type == "s":
                    self.ignore_netdevice_speed = True if int(_part[1]) else False

    @staticmethod
    def flags_to_str(obj):
        return "d{}:s{}".format(
            obj.desired_status,
            "1" if obj.ignore_netdevice_speed else "0"
        )


class netdevice(models.Model):
    idx = models.AutoField(db_column="netdevice_idx", primary_key=True)
    device = models.ForeignKey("backbone.device")
    devname = models.CharField(max_length=64)
    macaddr = models.CharField(db_column="macadr", max_length=177, blank=True, default="")
    driver_options = models.CharField(max_length=672, blank=True)
    # speed is probably deprecated, use netdevice_speed instead
    speed = models.BigIntegerField(default=0, null=True, blank=True)
    netdevice_speed = models.ForeignKey("backbone.netdevice_speed")
    ignore_netdevice_speed = models.BooleanField(default=False)
    driver = models.CharField(max_length=384, blank=True, default="e1000e")
    # is a valid routing target
    routing = models.BooleanField(default=False)
    # inter-device routing enabled
    inter_device_routing = models.BooleanField(default=True)
    penalty = models.IntegerField(null=True, blank=True, default=1, verbose_name="cost")
    dhcp_device = models.NullBooleanField(null=True, blank=True, default=False)
    ethtool_options = models.IntegerField(null=True, blank=True, default=0)
    fake_macaddr = models.CharField(db_column="fake_macadr", max_length=177, blank=True, default="")
    network_device_type = models.ForeignKey("backbone.network_device_type")
    description = models.CharField(max_length=765, blank=True)
    # true for bridge master
    is_bridge = models.BooleanField(default=False)
    # true for bond master
    is_bond = models.BooleanField(default=False)
    bridge_device = models.ForeignKey("self", null=True, blank=True, related_name="bridge_slaves")
    bond_master = models.ForeignKey("self", null=True, blank=True, related_name="bond_slaves")
    bridge_name = models.CharField(max_length=765, blank=True)
    vlan_id = models.IntegerField(null=True, blank=True, default=0)
    # for VLAN devices
    master_device = models.ForeignKey("self", null=True, related_name="vlan_slaves", blank=True)
    # enabled for monitoring
    enabled = models.BooleanField(default=True)
    date = models.DateTimeField(auto_now_add=True)
    # maximum transfer unit
    mtu = models.IntegerField(default=1500)
    # snmp related fields, zero for non-SNMP fetched network devices
    snmp_idx = models.IntegerField(default=0)
    # force matching the network device types, defaults to True
    # also affects MAC-address matching
    force_network_device_type_match = models.BooleanField(default=True)
    # snmp network type
    snmp_network_type = models.ForeignKey("backbone.snmp_network_type", null=True, blank=True)
    # admin / oper stats
    snmp_admin_status = models.IntegerField(default=0)
    snmp_oper_status = models.IntegerField(default=0)
    # desired status
    desired_status = models.CharField(
        max_length=4,
        default=NetDeviceDesiredStateEnum.ignore.value,
        choices=[(_en.value, _en.name) for _en in NetDeviceDesiredStateEnum]
    )
    # wmi interface index, only set if device is scanned using wmi
    # https://msdn.microsoft.com/en-us/library/aa394217(v=vs.85).aspx
    wmi_interface_index = models.IntegerField(default=None, null=True, blank=True)

    def __init__(self, *args, **kwargs):
        models.Model.__init__(self, *args, **kwargs)
        self.saved_values = {
            "penalty": self.penalty,
            "routing": self.routing,
        }

    def copy(self):
        return netdevice(
            devname=self.devname,
            macaddr=self.get_dummy_macaddr(),
            driver_options=self.driver_options,
            inter_device_routing=self.inter_device_routing,
            speed=self.speed,
            netdevice_speed=self.netdevice_speed,
            driver=self.driver,
            routing=self.routing,
            penalty=self.penalty,
            dhcp_device=self.dhcp_device,
            ethtool_options=self.ethtool_options,
            fake_macaddr=self.get_dummy_macaddr(),
            network_device_type=self.network_device_type,
            description=self.description,
            is_bridge=self.is_bridge,
            is_bond=self.is_bond,
            bridge_name=self.bridge_name,
            vlan_id=self.vlan_id,
            enabled=self.enabled,
            mtu=self.mtu,
            force_network_device_type_match=self.force_network_device_type_match,
            snmp_network_type=self.snmp_network_type,
            snmp_admin_status=self.snmp_admin_status,
            snmp_oper_status=self.snmp_oper_status,
            # hm ...
            # bridge_device=self.bridge_device,
        )

    def find_matching_network_device_type(self):
        match_list = [ndt for ndt in network_device_type.objects.filter(Q(for_matching=True)) if ndt.match(self.devname)]
        if len(match_list) == 0:
            return None
        elif len(match_list) == 1:
            return match_list[0]
        else:
            # take ndt with shortest name_re
            return sorted([(len(ndt.name_re), ndt) for ndt in match_list])[0][1]

    def get_dummy_macaddr(self):
        return ":".join(["00"] * self.network_device_type.mac_bytes)

    class CSW_Meta:
        fk_ignore_list = ["net_ip", "peer_information"]

    class Meta:
        db_table = u'netdevice'
        ordering = ("snmp_idx", "devname",)
        verbose_name = "Netdevice"

    def delete(self, *args, **kwargs):
        super(netdevice, self).delete(*args, **kwargs)

    @property
    def ethtool_autoneg(self):
        return (self.ethtool_options or 0) & 3

    @property
    def ethtool_duplex(self):
        return ((self.ethtool_options or 0) >> 2) & 3

    @property
    def ethtool_speed(self):
        return ((self.ethtool_options or 0) >> 4) & 7

    @ethtool_autoneg.setter
    def ethtool_autoneg(self, in_val):
        self.ethtool_options = ((self.ethtool_options or 0) & ~3) | int(in_val)

    @ethtool_duplex.setter
    def ethtool_duplex(self, in_val):
        self.ethtool_options = ((self.ethtool_options or 0) & ~12) | (int(in_val) << 2)

    @ethtool_speed.setter
    def ethtool_speed(self, in_val):
        self.ethtool_options = ((self.ethtool_options or 0) & 15) | (int(in_val) << 4)

    def ethtool_string(self):
        return ",".join(["FIXME", "ethool_string()"])

    def __unicode__(self):
        return self.devname


@receiver(signals.pre_delete, sender=netdevice)
def netdevice_pre_delete(sender, **kwargs):
    pass


@receiver(signals.pre_save, sender=netdevice)
def netdevice_pre_save(sender, **kwargs):
    if "instance" in kwargs:
        cur_inst = kwargs["instance"]
        if cur_inst.devname:
            cur_inst.devname = cur_inst.devname[:63]
        check_empty_string(cur_inst, "devname")
        check_integer(cur_inst, "mtu", min_val=0, max_val=65536)
        all_nd_names = netdevice.objects.exclude(
            Q(pk=cur_inst.pk)
        ).filter(
            Q(device=cur_inst.device_id)
        ).values_list(
            "devname",
            flat=True
        )
        if cur_inst.devname in all_nd_names:
            raise ValidationError("devname '{}' already used".format(cur_inst.devname))
        # change network_device_type
        if cur_inst.force_network_device_type_match:
            nd_type = cur_inst.find_matching_network_device_type()
            if nd_type is not None:
                cur_inst.network_device_type = nd_type
            else:
                _cs = config_store.ConfigStore(GEN_CS_NAME, quiet=True)
                if _cs["create.network.device.types"]:
                    cur_inst.network_device_type = network_device_type.create_new_type(cur_inst)
                else:
                    raise NoMatchingNetworkDeviceTypeFoundError(
                        "nothing found for '{}' ({})".format(
                            unicode(cur_inst),
                            cur_inst.pk or "new nd"
                        )
                    )
        else:
            if not cur_inst.network_device_type_id:
                # take the first one which is not used for matching
                cur_inst.network_device_type = network_device_type.objects.filter(Q(for_matching=False))[0]
        # fix None as vlan_id
        check_integer(cur_inst, "vlan_id", none_to_zero=True, min_val=0)
        # penalty
        check_integer(cur_inst, "penalty", min_val=1)
        # mac address matching (if needed)
        if cur_inst.force_network_device_type_match:
            # check mac address
            if cur_inst.macaddr:
                cur_inst.macaddr = cur_inst.macaddr.replace("-", ":").lower()
            if cur_inst.fake_macaddr:
                cur_inst.fake_macaddr = cur_inst.fake_macaddr.replace("-", ":").lower()
            dummy_mac, mac_re_str = (
                ":".join(
                    [
                        "00"
                    ] * cur_inst.network_device_type.mac_bytes
                ),
                "^{}$".format(
                    ":".join(
                        [
                            "[0-9a-f]{2}"
                        ] * cur_inst.network_device_type.mac_bytes
                    )
                ),
            )
            mac_re = re.compile(mac_re_str)
            # set empty if not set
            try:
                if not cur_inst.macaddr.strip() or int(cur_inst.macaddr.replace(":", ""), 16) == 0:
                    cur_inst.macaddr = dummy_mac
            except:
                raise ValidationError("MACaddress '{}' has illegal format".format(cur_inst.macaddr))
            # set empty if not set
            try:
                if not cur_inst.fake_macaddr.strip() or int(cur_inst.fake_macaddr.replace(":", ""), 16) == 0:
                    cur_inst.fake_macaddr = dummy_mac
            except:
                raise ValidationError("fake MACaddress '{}' has illegal format".format(cur_inst.fake_macaddr))
            if not mac_re.match(cur_inst.macaddr):
                raise ValidationError("MACaddress '{}' has illegal format for RE '{}'".format(cur_inst.macaddr, mac_re_str))
            if not mac_re.match(cur_inst.fake_macaddr):
                raise ValidationError("fake MACaddress '{}' has illegal format".format(cur_inst.fake_macaddr))
        if cur_inst.master_device_id:
            if not cur_inst.vlan_id:
                raise ValidationError("VLAN id cannot be zero")
            if cur_inst.master_device_id == cur_inst.pk:
                raise ValidationError("cannot be my own VLAN master")
            if cur_inst.master_device.master_device_id:
                raise ValidationError("cannot chain VLAN devices")

        if cur_inst.netdevice_speed_id is None:
            # set a default
            cur_inst.netdevice_speed = netdevice_speed.objects.get(Q(speed_bps=1000000000) & Q(full_duplex=True) & Q(check_via_ethtool=False))
        # if cur_inst.vlan_id and not cur_inst.master_device_id:
        #    raise ValidationError("need a VLAN master")


@receiver(signals.post_save, sender=netdevice)
def netdevice_post_save(sender, **kwargs):
    if "instance" in kwargs:
        _cur_inst = kwargs["instance"]
        if _cur_inst.device.bootserver_id:
            BootsettingsChanged.send(sender=_cur_inst, device=_cur_inst.device, cause="netdevice update")


@receiver(signals.post_delete, sender=netdevice)
def netdevice_post_delete(sender, **kwargs):
    if "instance" in kwargs:
        _cur_inst = kwargs["instance"]


class netdevice_speed(models.Model):
    idx = models.AutoField(db_column="netdevice_speed_idx", primary_key=True)
    speed_bps = models.BigIntegerField(null=True, blank=True)
    check_via_ethtool = models.BooleanField(default=True)
    full_duplex = models.BooleanField(default=True)
    date = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = u'netdevice_speed'
        ordering = ("speed_bps", "full_duplex")

    def info_string(self):
        return unicode(self)

    @staticmethod
    def build_lut():
        speed_dict = {}
        for _entry in netdevice_speed.objects.all().order_by("-check_via_ethtool", "-full_duplex"):
            if _entry.speed_bps not in speed_dict:
                speed_dict[_entry.speed_bps] = _entry
        return speed_dict

    def __unicode__(self):
        if self.speed_bps:
            _s_str, lut_idx = ("", 0)
            cur_s = self.speed_bps
            while cur_s > 999:
                cur_s = cur_s / 1000
                lut_idx += 1
            _speed_str = "{}{}Bps".format(
                cur_s,
                " kMGT"[lut_idx].strip()
            )
        else:
            _speed_str = "unspec."
        return u"{}, {} duplex, {}".format(
            _speed_str,
            "full" if self.full_duplex else "half",
            "check via ethtool" if self.check_via_ethtool else "no check"
        )


@receiver(signals.pre_save, sender=network_type)
def network_type_pre_save(sender, **kwargs):
    if "instance" in kwargs:
        cur_inst = kwargs["instance"]
        # raise ValidationError("test validation error")
        if not(cur_inst.identifier.strip()):
            raise ValidationError("identifer must not be empty")


class peer_information(models.Model):
    idx = models.AutoField(db_column="peer_information_idx", primary_key=True)
    s_netdevice = models.ForeignKey("backbone.netdevice", related_name="peer_s_netdevice")
    s_spec = models.CharField(default="", max_length=128, verbose_name="source spec", blank=True)
    d_netdevice = models.ForeignKey("backbone.netdevice", related_name="peer_d_netdevice")
    d_spec = models.CharField(default="", max_length=128, verbose_name="dest spec", blank=True)
    penalty = models.IntegerField(default=0, verbose_name="cost")
    # true for peers created via SNMP
    autocreated = models.BooleanField(default=False)
    info = models.CharField(default="", max_length=256, blank=True)
    date = models.DateTimeField(auto_now_add=True)

    def __unicode__(self):
        return u"{} [{:d}] {}".format(
            self.s_netdevice.devname,
            self.penalty,
            self.d_netdevice.devname
        )

    def get_s_device(self):
        return self.s_netdevice.device_id

    def get_d_device(self):
        return self.d_netdevice.device_id

    def store_before_delete(self, del_device):
        if self.s_netdevice.device_id == del_device.pk:
            other_nd = self.d_netdevice
            other_spec = self.d_spec
            my_name = self.s_netdevice.devname
            my_spec = self.s_spec
        else:
            other_nd = self.s_netdevice
            other_spec = self.s_spec
            my_name = self.d_netdevice.devname
            my_spec = self.d_spec
        return {
            "s_spec": self.s_spec,
            "penalty": self.penalty,
            "autocreated": self.autocreated,
            "info": self.info,
            "other_netdevice": other_nd,
            "my_name": my_name,
            "my_spec": my_spec,
            "other_spec": other_spec,
        }

    @staticmethod
    def create_from_store(peer_dict, new_nd):
        return peer_information.objects.create(
            s_netdevice=new_nd,
            s_spec=peer_dict["my_spec"],
            d_netdevice=peer_dict["other_netdevice"],
            d_spec=peer_dict["other_spec"],
            penalty=peer_dict["penalty"],
            autocreated=peer_dict["autocreated"],
            info=peer_dict["info"],
        )

    class Meta:
        db_table = u'peer_information'
        verbose_name = "Peer information"


@receiver(signals.pre_save, sender=peer_information)
def peer_information_pre_save(sender, **kwargs):
    if "instance" in kwargs:
        cur_inst = kwargs["instance"]
        try:
            _cur_peer = peer_information.objects.get(
                (
                    Q(s_netdevice=cur_inst.s_netdevice_id) &
                    Q(d_netdevice=cur_inst.d_netdevice_id)
                ) | (
                    Q(s_netdevice=cur_inst.d_netdevice_id) &
                    Q(d_netdevice=cur_inst.s_netdevice_id)
                )
            )
        except peer_information.DoesNotExist:
            pass
        else:
            if _cur_peer.pk != cur_inst.pk:
                raise ValidationError(
                    u"peer already exists [{} on {} --- {} on {}]".format(
                        cur_inst.s_netdevice.devname,
                        unicode(cur_inst.s_netdevice.device),
                        cur_inst.d_netdevice.devname,
                        unicode(cur_inst.d_netdevice.device),
                    )
                )
        check_integer(cur_inst, "penalty", min_val=1)


@receiver(signals.post_save, sender=peer_information)
def peer_information_post_save(sender, **kwargs):
    if not kwargs["raw"] and "instance" in kwargs:
        _cur_inst = kwargs["instance"]


@receiver(signals.post_delete, sender=peer_information)
def peer_information_post_delete(sender, **kwargs):
    if "instance" in kwargs:
        _cur_inst = kwargs["instance"]


class snmp_network_type(models.Model):
    idx = models.AutoField(primary_key=True)
    if_type = models.IntegerField(default=0)
    if_label = models.CharField(max_length=128, default="")
    date = models.DateTimeField(auto_now_add=True)
