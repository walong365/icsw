# -*- coding: utf-8 -*-
# Generated by Django 1.10.5 on 2017-02-16 13:25
from __future__ import unicode_literals
import re

from django.db import migrations, models
import django.db.models.deletion
from django.db.models import Q


def dummy_reverse(apps, schema_editor):
    pass


class IANAIfType(object):
    def __init__(self, idx, name, descr="", regex="", mac_bytes=6):
        self.idx = idx
        self.name = name
        self.description = descr
        self.regex = regex
        self.mac_bytes = mac_bytes

IANAIfTypes = [
    IANAIfType(1, "other", "none of the following", regex="^.*$"),
    IANAIfType(
        6,
        "ethernetCsmacd",
        "for all ethernet-like interfaces, regardless of speed, as per RFC3635",
        regex="^(eth|en).*$",
    ),
    IANAIfType(131, "tunnel", "Encapsulation interface", regex="^tun.*$"),
    IANAIfType(24, "softwareLoopback", regex="^lo.*$"),
    IANAIfType(199, "infiniband", "Infiniband", regex="^ib.*", mac_bytes=20),
]


def match(snmp_t, devname):
    if devname.count(":") == 1:
        _m_name = devname.split(":")[0]
    else:
        _m_name = devname
    return re.match(snmp_t.regex, _m_name)


def find_matching_snmp_network_type(in_dict, nd):
    match_list = [ndt for ndt in in_dict.values() if match(ndt, nd.devname)]
    if len(match_list) == 0:
        return None
    elif len(match_list) == 1:
        return match_list[0]
    else:
        # take ndt with shortest name_re
        return sorted(
            [
                (
                    len(ndt.regex),
                    ndt
                ) for ndt in match_list
            ],
            reverse=True
        )[0][1]


def migrate_network_types(apps, schema_editor):
    netdevice = apps.get_model("backbone", "netdevice")
    snmp_network_type = apps.get_model("backbone", "snmp_network_type")
    # create new types if not present
    _dict = {}
    for i_t in IANAIfTypes:
        try:
            _cur = snmp_network_type.objects.get(if_type=i_t.idx)
        except snmp_network_type.DoesNotExist:
            _cur = snmp_network_type.objects.create(
                if_type=i_t.idx,
                if_label=i_t.name,
                description=i_t.description,
                regex=i_t.regex,
                mac_bytes=i_t.mac_bytes,
            )
        else:
            _cur.regex = i_t.regex
            _cur.mac_bytes = i_t.mac_bytes
        _cur.save()
        _dict[_cur.idx] = _cur

    for nd in netdevice.objects.filter(Q(snmp_network_type__isnull=True)):
        nd.snmp_network_type = find_matching_snmp_network_type(_dict, nd)
        nd.save(update_fields=["snmp_network_type"])


class Migration(migrations.Migration):

    dependencies = [
        ('backbone', '1055_auto_20170216_1423'),
    ]

    operations = [
        migrations.RunPython(migrate_network_types, reverse_code=dummy_reverse),
    ]
